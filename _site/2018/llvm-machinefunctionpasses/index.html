<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Testing MachineFunctionPasses on LLVM without having to recompile every time</title>

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link href='//spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css' rel='stylesheet' type='text/css'>
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet">

  <link rel="alternate" type="application/rss+xml" title="RSS Feed for surruskij" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Testing MachineFunctionPasses on LLVM without having to recompile every time | surruskij</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Testing MachineFunctionPasses on LLVM without having to recompile every time" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Recompiling the whole LLVM infrastructure is a very tedious and long process. I’ll show you how to get away with it in just a few seconds." />
<meta property="og:description" content="Recompiling the whole LLVM infrastructure is a very tedious and long process. I’ll show you how to get away with it in just a few seconds." />
<link rel="canonical" href="http://localhost:4000/2018/llvm-machinefunctionpasses/" />
<meta property="og:url" content="http://localhost:4000/2018/llvm-machinefunctionpasses/" />
<meta property="og:site_name" content="surruskij" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-10-17T00:00:00+02:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2018/llvm-machinefunctionpasses/","headline":"Testing MachineFunctionPasses on LLVM without having to recompile every time","dateModified":"2018-10-17T00:00:00+02:00","datePublished":"2018-10-17T00:00:00+02:00","description":"Recompiling the whole LLVM infrastructure is a very tedious and long process. I’ll show you how to get away with it in just a few seconds.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018/llvm-machinefunctionpasses/"},"@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->



  <!-- Google Analytics -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130789124-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130789124-1');
</script>




</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000"><img id="logo" src="http://localhost:4000/assets/images/logo.png"></a>
  </div>
</header>
<div class="post">
  <div class="post-title">Testing MachineFunctionPasses on LLVM without having to recompile every time</div>
  <span class="post-date">
    <time>17 Oct 2018</time>
  </span>
  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#llvm">
          <span>llvm</span>
        </a>
      </li>
      
      
      <li>
        <a href="http://localhost:4000/tags#tutorial">
          <span>tutorial</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p>LLVM is an extremely beautiful project: its modularity enables anyone to extend the compiler infrastructure by writing modules to be used either on the backend or the frontend.</p>

<p>When it comes to extend the backend, however, LLVM gives us the possibility to choose the abstraction layer we want to work on: on one hand we can write passes that operate at the IR (Intermediate Representation) level, on the other we can go even deeper, writing a <code class="highlighter-rouge">MachineFunctionPass</code> to directly work at the assembly level of our target architecture.</p>

<p>While it is possible to develop normal passes outside the LLVM source tree, and dynamically load them using the <code class="highlighter-rouge">opt</code> tool, if we have to work on <code class="highlighter-rouge">MachineFunctionPasses</code> we have to recompile the whole backend each time we made a tiny modification to the pass code. <br />
This is due to the fact that our <code class="highlighter-rouge">MachineFunctionPass</code> is used only in the late stages of machine code generation, on MIR code (Machine IR, much more lower level); for this reason those passes are tightly coupled with the LLVM backend.</p>

<p>Since recompiling everything each time is unfeasible (it would take hours), I’ll show you a way to selectively recompile only parts of the backend, getting things done in seconds!</p>

<hr />

<h3 id="compiling-llvm">Compiling LLVM</h3>
<p>We will start from scratch: we will setup a faster and smarter build system (<code class="highlighter-rouge">ninja-build</code>), compile everything and once we have done with this, we won’t have to wait hours anymore.</p>

<ol>
  <li>
    <p><strong>Install</strong> all the <strong>prerequisites</strong>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ sudo apt install xz-utils cmake ninja-build clang
</code></pre></div>    </div>
  </li>
  <li><strong>Download</strong> LLVM 7.0 <strong>sources</strong> from <a href="http://releases.llvm.org/7.0.0/llvm-7.0.0.src.tar.xz">here</a></li>
  <li>
    <p><strong>Unpack</strong> them in a directory of your choice which will refer to as <code class="highlighter-rouge">[LLVM_SRC]</code>. I personally created a new directory outside the source folder.</p>
  </li>
  <li>
    <p>Create a <strong>build directory</strong>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ mkdir llvm-build
 $ cd llvm-build
</code></pre></div>    </div>
  </li>
  <li>
    <p>Let’s <strong>configure</strong> the build environment, instructing <code class="highlighter-rouge">cmake</code> as follows:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ cmake -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD=X86 -DBUILD_SHARED_LIBS=ON \
   ../llvm-7.0.0.src -GNinja
</code></pre></div>    </div>
    <p>As you can see, there are a couple of flags that are worth to be mentioned:</p>
    <ul>
      <li><code class="highlighter-rouge">-DCMAKE_BUILD_TYPE=Debug</code>: just to obtain a debug build (more flexible)</li>
      <li><code class="highlighter-rouge">-DLLVM_TARGETS_TO_BUILD=X86</code>: since we’re interested only in the X86 platform, we don’t want to lose time compiling the backend also for all the other platforms, such as ARM, MIPS, SPARC, etc. This speeds up the compilation process, and make us save up to 4 GB of disk space.</li>
      <li><code class="highlighter-rouge">-DBUILD_SHARED_LIBS=ON</code>: shared code is moved in <code class="highlighter-rouge">.so</code> libraries, that can be linked at runtime, thus speeding up the compilation process even more.</li>
      <li><code class="highlighter-rouge">-GNinja</code>: specifies to use <code class="highlighter-rouge">ninja</code> as build generator. By using <code class="highlighter-rouge">ninja</code> the overall compile time can decrease by more than 50% (it seems that it has better support to multithreading), but most importantly we can invoke a specific command to compile only <code class="highlighter-rouge">llc</code>.</li>
    </ul>
  </li>
  <li>
    <p>Now start the actual <strong>compilation</strong> within your build directory</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ cmake --build .
</code></pre></div>    </div>

    <p>Building takes some time to finish.</p>
  </li>
  <li>
    <p>Finally, we can create a symbolic link to our custom version of <code class="highlighter-rouge">llc</code>, in order to call it in a simpler way:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $ sudo ln -s [BUILD-PATH]/bin/llc /usr/local/bin/llc
</code></pre></div>    </div>
  </li>
</ol>

<h4 id="recompiling-llc">Recompiling LLC</h4>
<p>At this stage, every time we modify our <code class="highlighter-rouge">MachineFunctionPass</code>, we just have to tell <code class="highlighter-rouge">ninja-build</code> to recompile only <code class="highlighter-rouge">llc</code> (LLVM system compiler), without having to recompile the whole backend.</p>

<p>This is just a matter of seconds by running:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ninja llc
</code></pre></div></div>

<h3 id="running-experiments">Running experiments</h3>
<p><code class="highlighter-rouge">llc</code> works at the IR level, so we have to generate the <code class="highlighter-rouge">.ll</code> file out of our C program:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>clang -O0 -S -emit-llvm hello.c -o hello.ll
</code></pre></div></div>

<p>then we have to run only the code generation use <code class="highlighter-rouge">llc</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>llc hello.ll
</code></pre></div></div>

<p>The output is an <code class="highlighter-rouge">asm</code> file, that can be compiled simply with <code class="highlighter-rouge">gcc</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc hello.s -o hello
</code></pre></div></div>

<hr />
<p>That’s it!</p>

<p>I hope this will speed up your development as it did with me! ;)</p>


  <!-- Disqus -->
  
  <div class="post-disqus">
      <section id="disqus_thread"></section>
      <script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//surruskij-blog.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  </div>
  

</div>


    <!-- Documents about icons are here: http://fontawesome.io/icons/ -->
<div class="footer">
  <hr />
  <div class="footer-link">
    
	
	
	
	

    
    <a href="https://twitter.com/enea_fardelli"><i class="fa fa-twitter" aria-hidden="true"></i></a>
    

    
    <a href="https://github.com/surruskij"><i class="fa fa-github" aria-hidden="true"></i></a>
    
	
	
	
	

    
    <a href="https://www.linkedin.com/in/danieleferla"><i class="fa fa-linkedin" aria-hidden="true"></i></a>
    
	
	
	
	
	
	
	
	

    

    

    
    <a href="mailto:danieleferla1@gmail.com"><i class="fa fa-envelope" aria-hidden="true"></i></a>
    

  </div>
  © 2018 Daniele Ferla. All rights reserved.
</div>

  </div>
</body>
</html>
