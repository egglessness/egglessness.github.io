<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>_FORTIFY_SOURCE: explained</title>
 
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/favicons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/favicons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png">
  <link rel="manifest" href="/assets/favicons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/favicons/ms-icon-144x144.png">
  <meta name="theme-color" content="#5881bf">

  <!-- CSS -->
  <link rel="stylesheet" href="/assets/css/main.css" type="text/css">

  <!-- Font -->
  <link href="https://fonts.googleapis.com/css?family=Merriweather|Ubuntu+Mono|Lato" rel="stylesheet" lazyload>
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/brands.css" integrity="sha384-whKHCkwP9f4MyD1vda26+XRyEg2zkyZezur14Kxc784RxUU1E7HvWVYj9EoJnUV7" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/fontawesome.css" integrity="sha384-WK8BzK0mpgOdhCxq86nInFqSWLzR5UAsNg0MGX9aDaIIrFWQ38dGdhwnNCAoXFxL" crossorigin="anonymous">
  <link rel="alternate" type="application/rss+xml" title="RSS Feed for polycarp" href="/feed.xml" />
  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>_FORTIFY_SOURCE: explained | polycarp</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="_FORTIFY_SOURCE: explained" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Compilers like GCC and Clang give developers the possibility to secure buffers in their applications by supplying the _FORTIFY_SOURCE macro at compile time. In this post, we will see how does it work and what can it do for us." />
<meta property="og:description" content="Compilers like GCC and Clang give developers the possibility to secure buffers in their applications by supplying the _FORTIFY_SOURCE macro at compile time. In this post, we will see how does it work and what can it do for us." />
<link rel="canonical" href="http://localhost:4000/2019/fortify/" />
<meta property="og:url" content="http://localhost:4000/2019/fortify/" />
<meta property="og:site_name" content="polycarp" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-02-19T00:00:00+01:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/2019/fortify/","description":"Compilers like GCC and Clang give developers the possibility to secure buffers in their applications by supplying the _FORTIFY_SOURCE macro at compile time. In this post, we will see how does it work and what can it do for us.","headline":"_FORTIFY_SOURCE: explained","dateModified":"2019-02-19T00:00:00+01:00","datePublished":"2019-02-19T00:00:00+01:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/fortify/"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->



  <!-- Google Analytics -->

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-130789124-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-130789124-1');
</script>




</head>

<body>
  <div class="content-container">
    <header>
  <div class="header-small">
    <a href="http://localhost:4000" target="_self"><img id="logo" src="http://localhost:4000/assets/images/logo.png"></a>
  </div>
  <nav class="header-nav">
    
    
    <a href="/" target="_self">Blog</a>
     &nbsp/&nbsp 
    
    
    
    <a href="/about" target="_self">About</a>
    
    
    
  </nav>
</header>
<div class="page">
  <base target="_blank">

<div class="post">
  <div class="post-title">_FORTIFY_SOURCE: explained</div>
  <span class="post-date">
    <time>19 Feb 2019</time>
  </span>
  <div class="post-tag">
    <ul>
      
      <li>
        <a href="http://localhost:4000/tags#tutorial" target="_self">
          <span>tutorial</span>
        </a>
      </li>
      
      
    </ul>
  </div>

  <p>C programmers absolutely know that dealing with functions that copy memory from one place to another can be quite painful: if proper bound checks are not performed, an attacker may be able to trigger a buffer overflow on a vulnerable program, thus hijacking its normal execution flow.</p>

<p>Luckily, modern compilers make available the <code class="highlighter-rouge">_FORTIFY_SOURCE</code> macro, to further protect binaries against the most common buffer overflow attacks. Extra checks on memory are performed, and in case of imminent buffer overflow, the fortified program throws an exception that immediately terminates itself to avoid further damages.<br />
From the attacker’s point of view, one can check whether a program has been fortified during the compilation by using the <code class="highlighter-rouge">checksec</code> command on GDB with peda/gef.</p>

<p>Fortifying a program means that we instruct the compiler to:</p>

<ul>
  <li>
    <p>Print warnings <strong>at compile time</strong>, if the destination buffer of one the supported functions (see below) is smaller than the source. This can be done only if the size of source and destination are known at compile time, otherwise no warning is raised.</p>
  </li>
  <li>
    <p>Replace the calls to supported functions with calls their safer counterparts (easily recognisable since they are all named <code class="highlighter-rouge">__*_chk</code>). These alternative functions are semantically equivalent to the original ones, but they also take the size of the destination buffer as parameter, in order to abort the program <strong>at runtime</strong> if an overflow occurs.</p>

    <p>Note that, since executing bound checks sligthly impacts on the performance, the substitution is takes place only when needed: in case a call to a function is recognised as safe (source and destination size are known and correct), the call site remains untouched.</p>
  </li>
</ul>

<p>This macro is meant to protect the program only in presence of functions for the manipulation of strings and memory, such as:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memcpy, memset, stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf, vsprintf, vsnprintf, gets, ...
</code></pre></div></div>

<p>The complete list of supported functions can be deduced by looking at the contents of the <code class="highlighter-rouge">debug/</code> folder in the glibc <a href="https://sourceware.org/git/?p=glibc.git;a=tree;f=debug">source tree</a>.</p>

<p>To take advantage of this macro, we must follow the steps below:</p>

<ol>
  <li>Ensure that all the needed headers have been specified: fortify doesn’t work in presence of implicit declarations.</li>
  <li>Instruct the compiler to use an optimisation level equal or higher than 1 (<code class="highlighter-rouge">-O1</code>).</li>
  <li>Pass the flag <code class="highlighter-rouge">-D_FORTIFY_SOURCE=1</code>, to perform just basic checks that shouldn’t change the behaviour of programs, or <code class="highlighter-rouge">-D_FORTIFY_SOURCE=2</code>, to add some more checking, but with the possibility that some conforming programs might fail.</li>
  <li>Profit!</li>
</ol>

<h3 id="proof">Proof</h3>

<p>Here we can show the difference between a fortified program and an unprotected one. We can use the unsecure program below as example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="n">puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It simply takes the 1st argument, copies it in a buffer of 5 bytes, then prints its contents. A buffer overflow is triggered as soon as we supply an argument which is longer than the buffer.
We can now compile the program twice: one with the <code class="highlighter-rouge">D_FORTIFY_SOURCE</code> flag, the other without it. To obtain comparable results, we can use <code class="highlighter-rouge">-O1</code> as optimisation level:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc example.c -o example -O1
$ gcc example.c -o example_fortified -D_FORTIFY_SOURCE=1 -O1
</code></pre></div></div>

<p>When compiling the program without the fortify macro, the obtained disassembly of the main function is:</p>

<pre><code class="language-asm">   0x0000000000001145 &lt;+0&gt;:	push   rbx
   0x0000000000001146 &lt;+1&gt;:	sub    rsp,0x10
   0x000000000000114a &lt;+5&gt;:	mov    rsi,QWORD PTR [rsi+0x8]
   0x000000000000114e &lt;+9&gt;:	lea    rbx,[rsp+0xb]
   0x0000000000001153 &lt;+14&gt;:	mov    rdi,rbx
   0x0000000000001156 &lt;+17&gt;:	call   0x1030 &lt;strcpy@plt&gt;
   0x000000000000115b &lt;+22&gt;:	mov    rdi,rbx
   0x000000000000115e &lt;+25&gt;:	call   0x1040 &lt;puts@plt&gt;
   0x0000000000001163 &lt;+30&gt;:	mov    eax,0x0
   0x0000000000001168 &lt;+35&gt;:	add    rsp,0x10
   0x000000000000116c &lt;+39&gt;:	pop    rbx
   0x000000000000116d &lt;+40&gt;:	ret
</code></pre>

<p>On the other hand, when compiling the fortified program, no warning is shown by the compiler, since the size of the source buffer (<code class="highlighter-rouge">argv[1]</code>) cannot be known at compile time. However, looking at disassembly we have:</p>

<pre><code class="language-asm">   0x0000000000001145 &lt;+0&gt;:	push   rbx
   0x0000000000001146 &lt;+1&gt;:	sub    rsp,0x10
   0x000000000000114a &lt;+5&gt;:	mov    rsi,QWORD PTR [rsi+0x8]
   0x000000000000114e &lt;+9&gt;:	lea    rbx,[rsp+0xb]
   0x0000000000001153 &lt;+14&gt;:	mov    edx,0x5			# length of buf
   0x0000000000001158 &lt;+19&gt;:	mov    rdi,rbx
   0x000000000000115b &lt;+22&gt;:	call   0x1040 &lt;__strcpy_chk@plt&gt;
   0x0000000000001160 &lt;+27&gt;:	mov    rdi,rbx
   0x0000000000001163 &lt;+30&gt;:	call   0x1030 &lt;puts@plt&gt;
   0x0000000000001168 &lt;+35&gt;:	mov    eax,0x0
   0x000000000000116d &lt;+40&gt;:	add    rsp,0x10
   0x0000000000001171 &lt;+44&gt;:	pop    rbx
   0x0000000000001172 &lt;+45&gt;:	ret
</code></pre>

<p>The call to <code class="highlighter-rouge">strcpy</code> has been replaced with <code class="highlighter-rouge">__strcpy_chk</code>, which checks if the destination can hold all the source data even at runtime. Looking at the <a href="https://sourceware.org/git/?p=glibc.git;a=blob;f=debug/strcpy_chk.c">source code</a>, the inner workings of this new function seem pretty straightforward:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Copy SRC to DEST with checking of destination buffer overflow.  */</span>
<span class="kt">char</span> <span class="o">*</span> <span class="nf">__strcpy_chk</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">destlen</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span> <span class="p">(</span><span class="n">src</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">destlen</span><span class="p">)</span>
    <span class="n">__chk_fail</span> <span class="p">();</span>

  <span class="k">return</span> <span class="n">memcpy</span> <span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Let’s test the behaviour at runtime:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./example AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./example_fortified AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
*** buffer overflow detected ***: ./example_fortified terminated
Aborted
</code></pre></div></div>

<h3 id="limitations">Limitations</h3>

<p>Even if the macro is highly effective in cases like the one above, not all the possible scenarios in which a buffer overflow occurs can be handled.</p>

<p>Let’s suppose to have the following program:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span> <span class="n">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">];</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="n">puts</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This program takes two arguments: the first is used as length for <code class="highlighter-rouge">buf</code>, the second is just the string we want to copy in it. Hence, this time, the buffer size is chosen at runtime.</p>

<p>Compiling with <code class="highlighter-rouge">gcc limited.c -o limited -O1 -D_FORTIFY_SOURCE=2</code>, no warning is showed, and disassemblying the binary we obtain:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 0x0000000000001155 &lt;+0&gt;:	push   rbp
   0x0000000000001156 &lt;+1&gt;:	mov    rbp,rsp
   0x0000000000001159 &lt;+4&gt;:	push   rbx
   0x000000000000115a &lt;+5&gt;:	sub    rsp,0x8
   0x000000000000115e &lt;+9&gt;:	mov    rbx,rsi
   0x0000000000001161 &lt;+12&gt;:	mov    rdi,QWORD PTR [rsi+0x8]
   0x0000000000001165 &lt;+16&gt;:	mov    edx,0xa
   0x000000000000116a &lt;+21&gt;:	mov    esi,0x0
   0x000000000000116f &lt;+26&gt;:	call   0x1050 &lt;strtol@plt&gt;
   0x0000000000001174 &lt;+31&gt;:	add    rax,0xf
   0x0000000000001178 &lt;+35&gt;:	and    rax,0xfffffffffffffff0
   0x000000000000117c &lt;+39&gt;:	sub    rsp,rax
   0x000000000000117f &lt;+42&gt;:	mov    rsi,QWORD PTR [rbx+0x10]
   0x0000000000001183 &lt;+46&gt;:	mov    rdi,rsp
   0x0000000000001186 &lt;+49&gt;:	call   0x1030 &lt;strcpy@plt&gt;
   0x000000000000118b &lt;+54&gt;:	mov    rdi,rsp
   0x000000000000118e &lt;+57&gt;:	call   0x1040 &lt;puts@plt&gt;
   0x0000000000001193 &lt;+62&gt;:	mov    eax,0x0
   0x0000000000001198 &lt;+67&gt;:	mov    rbx,QWORD PTR [rbp-0x8]
   0x000000000000119c &lt;+71&gt;:	leave
   0x000000000000119d &lt;+72&gt;:	ret
</code></pre></div></div>

<p>As you may notice, this time the call for <code class="highlighter-rouge">strcpy</code> hasn’t been replaced, leaving the binary vulnerable:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ./limited 3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
</code></pre></div></div>

<p>Hence, the macro does not help in case the size of the destination buffer cannot be known at compile time!</p>

<h3 id="conclusion">Conclusion</h3>

<p>When compiling a program, using the <code class="highlighter-rouge">_FORTIFY_SOURCE</code> flag is a good programming practice to be aware of possible vulnerabilities reading the compiler warnings, and to automatically replace vulnerable functions with safer ones. However, this only adds an extra level of security, leaving unprotected functions that take parameters not known at compile time.</p>



</div>

</div>


    
<div class="footer">
  <hr />
  <div class="footer-link">
    
	
	
	
	

    
    <a href="https://twitter.com/surruskij" target="_blank"><i class="fab fa-twitter" aria-hidden="true"></i></a>
    

    
    <a href="https://github.com/surruskij" target="_blank"><i class="fab fa-github" aria-hidden="true"></i></a>
    
	
	
	
	

    
    <a href="https://www.linkedin.com/in/danieleferla" target="_blank"><i class="fab fa-linkedin" aria-hidden="true"></i></a>
    
	
	
	
	
	
	
	
	

    

    

    

  </div>
  © 2019 Daniele Ferla. All rights reserved.
</div>

  </div>
</body>
</html>
