<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <title>polycarp - random notes on computer security</title>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>No, using strncpy won't really make you safer</title>
        <description>&lt;p&gt;A common belief among programmers is that functions like &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt; are more secure than &lt;code class=&quot;highlighter-rouge&quot;&gt;strcpy&lt;/code&gt;, due to the fact that the former accepts the number of bytes to copy, while the latter doesn’t. This allows a developer to pass the size of the destination buffer to &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt;, avoiding to overflow it in case we’re copying data from a possibly unbounded source.&lt;/p&gt;

&lt;p&gt;However, this doens’t mean that &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; secure. In &lt;a href=&quot;https://grsecurity.net/huawei_and_security_analysis.php&quot;&gt;this article&lt;/a&gt; grsecurity researchers demonstrate that naively grouping APIs in “safe” or “unsafe”  can lead to wrong assumptions, regarding the best function to use.&lt;/p&gt;

&lt;p&gt;To start with a basic example, let’s take a look at the following program:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define BUF_SIZE 10
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;secret string!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUF_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;strncpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BUF_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see, we are diligently using &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; because our source (&lt;code class=&quot;highlighter-rouge&quot;&gt;argv[1]&lt;/code&gt;) is potentially unbounded, so we copy only &lt;code class=&quot;highlighter-rouge&quot;&gt;BUF_SIZE&lt;/code&gt; bytes from source to destination.&lt;/p&gt;

&lt;p&gt;However, if there isn’t a null terminator in the first &lt;code class=&quot;highlighter-rouge&quot;&gt;BUF_SIZE&lt;/code&gt; bytes of &lt;code class=&quot;highlighter-rouge&quot;&gt;argv[1]&lt;/code&gt;, the destination buffer will hold a non-terminated string. The result? An attacker can leak all the stack variables, until a NULL byte is reached.&lt;/p&gt;

&lt;p&gt;Let’s test this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./vuln AAAAAA
AAAAAA
$ ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAsecret string!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we pass as argument a string longer than 10 bytes, it will be copied in &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt; without the null terminator, leaking our precious secret.&lt;/p&gt;

&lt;p&gt;The story on the article is even funnier: once a programmer, wanting to avoid the behaviour above without adding further checks or purposely add a NULL byte at the end of the destination buffer, replaced all the calls for &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt; in the crypto module of the Linux kernel with &lt;code class=&quot;highlighter-rouge&quot;&gt;strlcpy&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This function (non-POSIX, but available via &lt;code class=&quot;highlighter-rouge&quot;&gt;libbsd&lt;/code&gt;) is very similar to &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt;: it takes the same arguments of &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt;, but always adds a null terminator at the end of the destination buffer.&lt;/p&gt;

&lt;p&gt;This substitution solved a problem, but introduced another one. Turns out that, while &lt;code class=&quot;highlighter-rouge&quot;&gt;strncpy&lt;/code&gt; also zero-pads the destination buffer in the case the source is shorter than the destination,  &lt;code class=&quot;highlighter-rouge&quot;&gt;strlcpy&lt;/code&gt; doesn’t. In the latter case, &lt;code class=&quot;highlighter-rouge&quot;&gt;strlcpy&lt;/code&gt; introduced an issue that could lead to information leak, since old data may be present on the destination buffer.&lt;/p&gt;

&lt;p&gt;So, what’s the takeaway? Well, there are two actually:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Man pages are your friends. Side-effects and other warnings are always reported in the man page of each function. Take always a look to them!&lt;/li&gt;
  &lt;li&gt;Most of the time, a function is not safe/unsafe per se, but it always depends on the context around. Being aware of this can avoid to fall into wrong assumptions.&lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Tue, 09 Apr 2019 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/2019/strncpy-wont-make-you-safer/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/strncpy-wont-make-you-safer/</guid>
      </item>
    
      <item>
        <title>_FORTIFY_SOURCE: explained</title>
        <description>&lt;p&gt;C programmers absolutely know that dealing with functions that copy memory from one place to another can be quite painful: if proper bound checks are not performed, an attacker may be able to trigger a buffer overflow on a vulnerable program, thus hijacking its normal execution flow.&lt;/p&gt;

&lt;p&gt;Luckily, modern compilers make available the &lt;code class=&quot;highlighter-rouge&quot;&gt;_FORTIFY_SOURCE&lt;/code&gt; macro, to further protect binaries against the most common buffer overflow attacks. Extra checks on memory are performed, and in case of imminent buffer overflow, the fortified program throws an exception that immediately terminates itself to avoid further damages.&lt;br /&gt;
From the attacker’s point of view, one can check whether a program has been fortified during the compilation by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;checksec&lt;/code&gt; command on GDB with peda/gef.&lt;/p&gt;

&lt;p&gt;Fortifying a program means that we instruct the compiler to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Print warnings &lt;strong&gt;at compile time&lt;/strong&gt;, if the destination buffer of one the supported functions (see below) is smaller than the source. This can be done only if the size of source and destination are known at compile time, otherwise no warning is raised.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Replace the calls to supported functions with calls their safer counterparts (easily recognisable since they are all named &lt;code class=&quot;highlighter-rouge&quot;&gt;__*_chk&lt;/code&gt;). These alternative functions are semantically equivalent to the original ones, but they also take the size of the destination buffer as parameter, in order to abort the program &lt;strong&gt;at runtime&lt;/strong&gt; if an overflow occurs.&lt;/p&gt;

    &lt;p&gt;Note that, since executing bound checks sligthly impacts on the performance, the substitution is takes place only when needed: in case a call to a function is recognised as safe (source and destination size are known and correct), the call site remains untouched.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This macro is meant to protect the program only in presence of functions for the manipulation of strings and memory, such as:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;memcpy, memset, stpcpy, strcpy, strncpy, strcat, strncat, sprintf, snprintf, vsprintf, vsnprintf, gets, ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The complete list of supported functions can be deduced by looking at the contents of the &lt;code class=&quot;highlighter-rouge&quot;&gt;debug/&lt;/code&gt; folder in the glibc &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=tree;f=debug&quot;&gt;source tree&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To take advantage of this macro, we must follow the steps below:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ensure that all the needed headers have been specified: fortify doesn’t work in presence of implicit declarations.&lt;/li&gt;
  &lt;li&gt;Instruct the compiler to use an optimisation level equal or higher than 1 (&lt;code class=&quot;highlighter-rouge&quot;&gt;-O1&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Pass the flag &lt;code class=&quot;highlighter-rouge&quot;&gt;-D_FORTIFY_SOURCE=1&lt;/code&gt;, to perform just basic checks that shouldn’t change the behaviour of programs, or &lt;code class=&quot;highlighter-rouge&quot;&gt;-D_FORTIFY_SOURCE=2&lt;/code&gt;, to add some more checking, but with the possibility that some conforming programs might fail.&lt;/li&gt;
  &lt;li&gt;Profit!&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;proof&quot;&gt;Proof&lt;/h3&gt;

&lt;p&gt;Here we can show the difference between a fortified program and an unprotected one. We can use the unsecure program below as example:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It simply takes the 1st argument, copies it in a buffer of 5 bytes, then prints its contents. A buffer overflow is triggered as soon as we supply an argument which is longer than the buffer.
We can now compile the program twice: one with the &lt;code class=&quot;highlighter-rouge&quot;&gt;D_FORTIFY_SOURCE&lt;/code&gt; flag, the other without it. To obtain comparable results, we can use &lt;code class=&quot;highlighter-rouge&quot;&gt;-O1&lt;/code&gt; as optimisation level:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gcc example.c -o example -O1
$ gcc example.c -o example_fortified -D_FORTIFY_SOURCE=1 -O1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When compiling the program without the fortify macro, the obtained disassembly of the main function is:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;   0x0000000000001145 &amp;lt;+0&amp;gt;:	push   rbx
   0x0000000000001146 &amp;lt;+1&amp;gt;:	sub    rsp,0x10
   0x000000000000114a &amp;lt;+5&amp;gt;:	mov    rsi,QWORD PTR [rsi+0x8]
   0x000000000000114e &amp;lt;+9&amp;gt;:	lea    rbx,[rsp+0xb]
   0x0000000000001153 &amp;lt;+14&amp;gt;:	mov    rdi,rbx
   0x0000000000001156 &amp;lt;+17&amp;gt;:	call   0x1030 &amp;lt;strcpy@plt&amp;gt;
   0x000000000000115b &amp;lt;+22&amp;gt;:	mov    rdi,rbx
   0x000000000000115e &amp;lt;+25&amp;gt;:	call   0x1040 &amp;lt;puts@plt&amp;gt;
   0x0000000000001163 &amp;lt;+30&amp;gt;:	mov    eax,0x0
   0x0000000000001168 &amp;lt;+35&amp;gt;:	add    rsp,0x10
   0x000000000000116c &amp;lt;+39&amp;gt;:	pop    rbx
   0x000000000000116d &amp;lt;+40&amp;gt;:	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, when compiling the fortified program, no warning is shown by the compiler, since the size of the source buffer (&lt;code class=&quot;highlighter-rouge&quot;&gt;argv[1]&lt;/code&gt;) cannot be known at compile time. However, looking at disassembly we have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-asm&quot;&gt;   0x0000000000001145 &amp;lt;+0&amp;gt;:	push   rbx
   0x0000000000001146 &amp;lt;+1&amp;gt;:	sub    rsp,0x10
   0x000000000000114a &amp;lt;+5&amp;gt;:	mov    rsi,QWORD PTR [rsi+0x8]
   0x000000000000114e &amp;lt;+9&amp;gt;:	lea    rbx,[rsp+0xb]
   0x0000000000001153 &amp;lt;+14&amp;gt;:	mov    edx,0x5			# length of buf
   0x0000000000001158 &amp;lt;+19&amp;gt;:	mov    rdi,rbx
   0x000000000000115b &amp;lt;+22&amp;gt;:	call   0x1040 &amp;lt;__strcpy_chk@plt&amp;gt;
   0x0000000000001160 &amp;lt;+27&amp;gt;:	mov    rdi,rbx
   0x0000000000001163 &amp;lt;+30&amp;gt;:	call   0x1030 &amp;lt;puts@plt&amp;gt;
   0x0000000000001168 &amp;lt;+35&amp;gt;:	mov    eax,0x0
   0x000000000000116d &amp;lt;+40&amp;gt;:	add    rsp,0x10
   0x0000000000001171 &amp;lt;+44&amp;gt;:	pop    rbx
   0x0000000000001172 &amp;lt;+45&amp;gt;:	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The call to &lt;code class=&quot;highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; has been replaced with &lt;code class=&quot;highlighter-rouge&quot;&gt;__strcpy_chk&lt;/code&gt;, which checks if the destination can hold all the source data even at runtime. Looking at the &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=blob;f=debug/strcpy_chk.c&quot;&gt;source code&lt;/a&gt;, the inner workings of this new function seem pretty straightforward:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* Copy SRC to DEST with checking of destination buffer overflow.  */&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__strcpy_chk&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;destlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;__chk_fail&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memcpy&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Let’s test the behaviour at runtime:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./example AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./example_fortified AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
*** buffer overflow detected ***: ./example_fortified terminated
Aborted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;limitations&quot;&gt;Limitations&lt;/h3&gt;

&lt;p&gt;Even if the macro is highly effective in cases like the one above, not all the possible scenarios in which a buffer overflow occurs can be handled.&lt;/p&gt;

&lt;p&gt;Let’s suppose to have the following program:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strtol&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;puts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program takes two arguments: the first is used as length for &lt;code class=&quot;highlighter-rouge&quot;&gt;buf&lt;/code&gt;, the second is just the string we want to copy in it. Hence, this time, the buffer size is chosen at runtime.&lt;/p&gt;

&lt;p&gt;Compiling with &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc limited.c -o limited -O1 -D_FORTIFY_SOURCE=2&lt;/code&gt;, no warning is showed, and disassemblying the binary we obtain:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	 0x0000000000001155 &amp;lt;+0&amp;gt;:	push   rbp
   0x0000000000001156 &amp;lt;+1&amp;gt;:	mov    rbp,rsp
   0x0000000000001159 &amp;lt;+4&amp;gt;:	push   rbx
   0x000000000000115a &amp;lt;+5&amp;gt;:	sub    rsp,0x8
   0x000000000000115e &amp;lt;+9&amp;gt;:	mov    rbx,rsi
   0x0000000000001161 &amp;lt;+12&amp;gt;:	mov    rdi,QWORD PTR [rsi+0x8]
   0x0000000000001165 &amp;lt;+16&amp;gt;:	mov    edx,0xa
   0x000000000000116a &amp;lt;+21&amp;gt;:	mov    esi,0x0
   0x000000000000116f &amp;lt;+26&amp;gt;:	call   0x1050 &amp;lt;strtol@plt&amp;gt;
   0x0000000000001174 &amp;lt;+31&amp;gt;:	add    rax,0xf
   0x0000000000001178 &amp;lt;+35&amp;gt;:	and    rax,0xfffffffffffffff0
   0x000000000000117c &amp;lt;+39&amp;gt;:	sub    rsp,rax
   0x000000000000117f &amp;lt;+42&amp;gt;:	mov    rsi,QWORD PTR [rbx+0x10]
   0x0000000000001183 &amp;lt;+46&amp;gt;:	mov    rdi,rsp
   0x0000000000001186 &amp;lt;+49&amp;gt;:	call   0x1030 &amp;lt;strcpy@plt&amp;gt;
   0x000000000000118b &amp;lt;+54&amp;gt;:	mov    rdi,rsp
   0x000000000000118e &amp;lt;+57&amp;gt;:	call   0x1040 &amp;lt;puts@plt&amp;gt;
   0x0000000000001193 &amp;lt;+62&amp;gt;:	mov    eax,0x0
   0x0000000000001198 &amp;lt;+67&amp;gt;:	mov    rbx,QWORD PTR [rbp-0x8]
   0x000000000000119c &amp;lt;+71&amp;gt;:	leave
   0x000000000000119d &amp;lt;+72&amp;gt;:	ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you may notice, this time the call for &lt;code class=&quot;highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; hasn’t been replaced, leaving the binary vulnerable:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./limited 3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hence, the macro does not help in case the size of the destination buffer cannot be known at compile time!&lt;/p&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;When compiling a program, using the &lt;code class=&quot;highlighter-rouge&quot;&gt;_FORTIFY_SOURCE&lt;/code&gt; flag is a good programming practice to be aware of possible vulnerabilities reading the compiler warnings, and to automatically replace vulnerable functions with safer ones. However, this only adds an extra level of security, leaving unprotected functions that take parameters not known at compile time.&lt;/p&gt;
</description>
        <pubDate>Tue, 19 Feb 2019 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2019/fortify/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/fortify/</guid>
      </item>
    
      <item>
        <title>Abusing Facebook prefetching to leak users IP address and user agent</title>
        <description>&lt;p&gt;In 2016 Facebook, aiming to improve final users experience, introduced &lt;strong&gt;link prefetching&lt;/strong&gt; as a way to reduce the load time of external webpages. 
As the &lt;a href=&quot;https://www.facebook.com/business/help/1514372351922333&quot;&gt;related Facebook help page&lt;/a&gt; states:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Prefetching allows Facebook to download mobile content before someone clicks a link. […] When someone clicks the link or call to action on your ad, a portion of the web page it’s linked to may already have been prefetched and will appear more quickly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Essentially, when you share on Facebook a rich link (i.e., a link that features title, thumbnail, and description), every time someone comes across to that post, &lt;strong&gt;without even clicking it&lt;/strong&gt;, his device loads the page and stores it for a certain amount of time: if the user decides to click on link, the page is already loaded.&lt;/p&gt;

&lt;p&gt;Cool, right? User experience can benefit from this, and page load times are slightly faster.&lt;br /&gt;
But, as always, cool features can be used by attackers to achieve completely different results.&lt;/p&gt;

&lt;p&gt;Since every time the device prefetches a webpage it fires a &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt; request to the server in which the page is located, I decided to do a simple experiment within my own local network.&lt;/p&gt;

&lt;p&gt;I set up a simple server using &lt;code class=&quot;highlighter-rouge&quot;&gt;Flask&lt;/code&gt; to log full headers of each incoming request; then I created a new post on Facebook, sharing a rich link to my server.&lt;/p&gt;

&lt;p&gt;Then, I logged in using a secondary Facebook account on my iPhone and,ì as soon as the news feed was loaded and the shared post became visible, without even touching anything, my server log started to talk very eloquently:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Referer: http://m.facebook.com
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_4_1 like Mac OS X) AppleWebKit/605.1.15 \
(KHTML, like Gecko) Mobile/15G77 [FBAN/FBIOS;FBDV/iPhone7,1;FBMD/iPhone;FBSN/iOS;FBSV/11.4.1;\
FBSS/3;FBCR/TIM;FBID/phone;FBLC/en_GB;FBOP/5;FBRV/127173516]
Connection: keep-alive
X-Purpose: preview
Host: 192.168.0.24
X-Fb-Http-Engine: Liger
X-Fb-Connection-Type: wifi
Accept-Encoding: gzip, deflate


192.168.0.23 - - [11/Oct/2018 18:41:02] &quot;GET / HTTP/1.1&quot; 200 -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can figure out that this request was fired for prefetching purposes by looking at these specific fields:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;X-Purpose: preview
X-Fb-Http-Engine: Liger
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is plenty of useful information about our target:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Device model&lt;/li&gt;
  &lt;li&gt;iOS version&lt;/li&gt;
  &lt;li&gt;Carrier operator (FBCR)&lt;/li&gt;
  &lt;li&gt;Device locale&lt;/li&gt;
  &lt;li&gt;IP address (so very coarse location information if the target isn’t using proxies/VPNs)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Obviously, this works also outside the local network: a simple IP logger service (like &lt;a href=&quot;https://grabify.link/&quot;&gt;Grabify&lt;/a&gt;) was enough to generate a URL that can stealthily log request headers and redirect the user wherever I want.&lt;br /&gt;
The result? I was able to collect the same data with no effort.&lt;/p&gt;

&lt;h3 id=&quot;affected-users&quot;&gt;Affected users&lt;/h3&gt;
&lt;p&gt;At the time of the discovery, only iOS users having the build &lt;code class=&quot;highlighter-rouge&quot;&gt;192.0.0.61.85&lt;/code&gt; installed were affected.&lt;/p&gt;

&lt;p&gt;I tried to repeat the same steps using an Android device, but without success (prefetching appears to be disabled at all).&lt;/p&gt;

&lt;h3 id=&quot;unaware-users-unaware-attackers&quot;&gt;Unaware users, unaware attackers&lt;/h3&gt;
&lt;p&gt;Since link prefetching was a feature enabled by default, potentially every person that shared rich links could spy on users behaviour, using a profile, a group or a page as an attack vector.
Moreover, by using this trick and leveraging on privacy controls to shared posts, making them visible to a specific person, it was possible to target an individual strictly.&lt;/p&gt;

&lt;p&gt;One can argue: “IP addresses and user agents are not such a big deal! Every time a user browses a website, he leaves the same kind of tracks behind his back”.&lt;br /&gt;
The fact is that, in this particular situation, &lt;strong&gt;people didn’t know anything about this behaviour&lt;/strong&gt;, because:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the only reference given by Facebook can be found in the help section for businesses&lt;/li&gt;
  &lt;li&gt;even if a user read that passage, there aren’t any details on the particularly abundant amount of data that is sent just for the sake of previewing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I just want to stress more on the second point.
An &lt;a href=&quot;https://www.eff.org/it/deeplinks/2010/01/tracking-by-user-agent&quot;&gt;experiment&lt;/a&gt; carried by the EFF (Electronic Frontier Foundation) in 2010 showed that:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Browsers usually convey between 5 and 15 bits of identifying information, about 10.5 bits on average. 
10 bits of identifying information would allow you to be picked out of a crowd of 2^10, or 1024 people.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The fun fact is that in this experiment analysed user agents were like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.27 Safari/532.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;which is nothing compared with the huge amount of data carried by the FB in-app browser:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mozilla/5.0 (iPhone; CPU iPhone OS 11_4_1 like Mac OS X) AppleWebKit/605.1.15 \
(KHTML, like Gecko) Mobile/15G77 [FBAN/FBIOS;FBDV/iPhone7,1;FBMD/iPhone;FBSN/iOS;FBSV/11.4.1;\
FBSS/3;FBCR/TIM;FBID/phone;FBLC/en_GB;FBOP/5;FBRV/127173516]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For this reason, even if I didn’t run any actual experiment, I believe that the number of bits of entropy on the latter kind of user agent can be far higher, thus leading to a unique identification within an even larger crowd of people.&lt;/p&gt;

&lt;h3 id=&quot;timetable&quot;&gt;Timetable&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;11 October 2018: vulnerability found and reported to Facebook&lt;/li&gt;
  &lt;li&gt;22 October 2018: investigation started by the appropriate product team&lt;/li&gt;
  &lt;li&gt;5 November 2018 (ish): prefetching appears to be disabled, thus closing the vulnerability&lt;/li&gt;
  &lt;li&gt;14 December 2018: official notification by the Facebook security team, and $1000 bounty awarded&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 14 Dec 2018 00:00:00 +0100</pubDate>
        <link>http://localhost:4000/2018/abusing-facebook-prefetching/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/abusing-facebook-prefetching/</guid>
      </item>
    
      <item>
        <title>Testing a MachineFunctionPass on LLVM without having to recompile every time</title>
        <description>&lt;p&gt;LLVM is an extremely beautiful project: its modularity enables anyone to extend the compiler infrastructure by writing modules to be used either on the backend or the frontend.&lt;/p&gt;

&lt;p&gt;When it comes to extend the backend, however, LLVM gives us the possibility to choose the abstraction layer we want to work on: on one hand we can write passes that operate at the IR (Intermediate Representation) level, on the other we can go even deeper, writing a &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineFunctionPass&lt;/code&gt; to directly work at the assembly level of our target architecture.&lt;/p&gt;

&lt;p&gt;While it is possible to develop normal passes outside the LLVM source tree, and dynamically load them using the &lt;code class=&quot;highlighter-rouge&quot;&gt;opt&lt;/code&gt; tool, if we have to work on &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineFunctionPasses&lt;/code&gt; we have to recompile the whole backend each time we made a tiny modification to the pass code. &lt;br /&gt;
This is due to the fact that our &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineFunctionPass&lt;/code&gt; is used only in the late stages of machine code generation, on MIR code (Machine IR, much more lower level); for this reason those passes are tightly coupled with the LLVM backend.&lt;/p&gt;

&lt;p&gt;Since recompiling everything each time is unfeasible (it would take hours), I’ll show you a way to selectively recompile only parts of the backend, getting things done in seconds!&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;compiling-llvm&quot;&gt;Compiling LLVM&lt;/h3&gt;
&lt;p&gt;We will start from scratch: we will setup a faster and smarter build system (&lt;code class=&quot;highlighter-rouge&quot;&gt;ninja-build&lt;/code&gt;), compile everything and once we have done with this, we won’t have to wait hours anymore.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Install&lt;/strong&gt; all the &lt;strong&gt;prerequisites&lt;/strong&gt;:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo apt install xz-utils cmake ninja-build clang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Download&lt;/strong&gt; LLVM 7.0 &lt;strong&gt;sources&lt;/strong&gt; from &lt;a href=&quot;http://releases.llvm.org/7.0.0/llvm-7.0.0.src.tar.xz&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Unpack&lt;/strong&gt; them in a directory of your choice which will refer to as &lt;code class=&quot;highlighter-rouge&quot;&gt;[LLVM_SRC]&lt;/code&gt;. I personally created a new directory outside the source folder.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Create a &lt;strong&gt;build directory&lt;/strong&gt;:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ mkdir llvm-build
 $ cd llvm-build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Let’s &lt;strong&gt;configure&lt;/strong&gt; the build environment, instructing &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; as follows:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cmake -DCMAKE_BUILD_TYPE=Debug -DLLVM_TARGETS_TO_BUILD=X86 -DBUILD_SHARED_LIBS=ON \
   ../llvm-7.0.0.src -GNinja
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;As you can see, there are a couple of flags that are worth to be mentioned:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-DCMAKE_BUILD_TYPE=Debug&lt;/code&gt;: just to obtain a debug build (more flexible)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-DLLVM_TARGETS_TO_BUILD=X86&lt;/code&gt;: since we’re interested only in the X86 platform, we don’t want to lose time compiling the backend also for all the other platforms, such as ARM, MIPS, SPARC, etc. This speeds up the compilation process, and make us save up to 4 GB of disk space.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-DBUILD_SHARED_LIBS=ON&lt;/code&gt;: shared code is moved in &lt;code class=&quot;highlighter-rouge&quot;&gt;.so&lt;/code&gt; libraries, that can be linked at runtime, thus speeding up the compilation process even more.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-GNinja&lt;/code&gt;: specifies to use &lt;code class=&quot;highlighter-rouge&quot;&gt;ninja&lt;/code&gt; as build generator. By using &lt;code class=&quot;highlighter-rouge&quot;&gt;ninja&lt;/code&gt; the overall compile time can decrease by more than 50% (it seems that it has better support to multithreading), but most importantly we can invoke a specific command to compile only &lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now start the actual &lt;strong&gt;compilation&lt;/strong&gt; within your build directory&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ cmake --build .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Building takes some time to finish.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally, we can create a symbolic link to our custom version of &lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt;, in order to call it in a simpler way:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ sudo ln -s [BUILD-PATH]/bin/llc /usr/local/bin/llc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;recompiling-llc&quot;&gt;Recompiling LLC&lt;/h4&gt;
&lt;p&gt;At this stage, every time we modify our &lt;code class=&quot;highlighter-rouge&quot;&gt;MachineFunctionPass&lt;/code&gt;, we just have to tell &lt;code class=&quot;highlighter-rouge&quot;&gt;ninja-build&lt;/code&gt; to recompile only &lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt; (LLVM system compiler), without having to recompile the whole backend.&lt;/p&gt;

&lt;p&gt;This is just a matter of seconds by running:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ninja llc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;running-experiments&quot;&gt;Running experiments&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt; works at the IR level, so we have to generate the &lt;code class=&quot;highlighter-rouge&quot;&gt;.ll&lt;/code&gt; file out of our C program:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -O0 -S -emit-llvm hello.c -o hello.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;then we have to run only the code generation use &lt;code class=&quot;highlighter-rouge&quot;&gt;llc&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;llc hello.ll
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The output is an &lt;code class=&quot;highlighter-rouge&quot;&gt;asm&lt;/code&gt; file, that can be compiled simply with &lt;code class=&quot;highlighter-rouge&quot;&gt;gcc&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc hello.s -o hello
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;p&gt;That’s it!&lt;/p&gt;

&lt;p&gt;I hope this will speed up your development as it did with me! ;)&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Oct 2018 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/2018/llvm-machinefunctionpasses/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/llvm-machinefunctionpasses/</guid>
      </item>
    
  </channel>
</rss>
